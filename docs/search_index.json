[["index.html", "Statistical Human Genetics course using R Originally a SMARTbiomed Summer course About Prerequisites License Author Contact", " Statistical Human Genetics course using R Originally a SMARTbiomed Summer course Florian Privé &amp; Isabelle McGrath 2025-06-05 About Prerequisites Have at least a basic knowledge of R, Install R (&gt;= 3.4) and RStudio (&gt;= 1.2), Install recent versions of {bigstatsr}, {bigsnpr}, and {susieR} (e.g. from CRAN), Download the data used in the tutorials: runonce::download_file( &quot;https://figshare.com/ndownloader/files/38019072&quot;, dir = &quot;tmp-data&quot;, fname = &quot;GWAS_data.zip&quot;) # 109 MB runonce::download_file( &quot;https://figshare.com/ndownloader/files/38019027&quot;, dir = &quot;tmp-data&quot;, fname = &quot;ref_freqs.csv.gz&quot;) # 46 MB runonce::download_file( &quot;https://figshare.com/ndownloader/files/38019024&quot;, dir = &quot;tmp-data&quot;, fname = &quot;projection.csv.gz&quot;) # 44 MB runonce::download_file( &quot;https://figshare.com/ndownloader/files/38077323&quot;, dir = &quot;tmp-data&quot;, fname = &quot;sumstats_CAD_tuto.csv.gz&quot;) # 16 MB runonce::download_file( &quot;https://figshare.com/ndownloader/files/38247288&quot;, dir = &quot;tmp-data&quot;, fname = &quot;gen_pos_tuto.rds&quot;) # 2.5 MB bigsnpr::download_plink(&quot;tmp-data&quot;) # 6.3 MB bigsnpr::download_plink2(&quot;tmp-data&quot;) # 6.6 MB #&gt; [1] &quot;tmp-data/GWAS_data.zip&quot; #&gt; [1] &quot;tmp-data/ref_freqs.csv.gz&quot; #&gt; [1] &quot;tmp-data/projection.csv.gz&quot; #&gt; [1] &quot;tmp-data/sumstats_CAD_tuto.csv.gz&quot; #&gt; [1] &quot;tmp-data/gen_pos_tuto.rds&quot; #&gt; [1] &quot;tmp-data/plink.exe&quot; #&gt; [1] &quot;tmp-data/plink2.exe&quot; License This material is licensed under the Creative Commons Attribution-ShareAlike 3.0 License. Author Florian Privé is a senior researcher in statistical human genetics, fond of Data Science and an R(cpp) enthusiast. You can find him on Bluesky and GitHub as @privefl. Contact If you want me to add or clarify some content in this course, please open an issue on the GitHub repository of this course. If you have bug reports or questions specifically on functions of the packages, please open an issue on the corresponding package’s repository. I will always redirect you to GitHub issues if you email me about the packages, so that others can benefit from our discussion. "],["inputs-and-formats.html", "Chapter 1 Inputs and formats 1.1 Formats of genetic data 1.2 The bigSNP format from {bigsnpr} 1.3 Getting a bigSNP object 1.4 The FBM format from {bigstatsr} 1.5 Working with an FBM", " Chapter 1 Inputs and formats 1.1 Formats of genetic data There exist many different data formats for genetic data: bed/bim/fam files (also called PLINK1 files), which respectively store genotype calls only (0, 1, 2, or NA) in a very condensed way (one byte only for 4 genotypes), information on the genetic variants, and information on the individuals. PLINK 1.9 and 2.0 provide many functions to work with this format. bgen files (usually one per chromosome), which can store imputed probabilities (P(0), P(1), P(2)) that are often transformed to dosage information (expected values: P(1) + 2P(2)). Each variant is stored compressed, which is very efficient for low-frequency variants. They are accompanied by bgen.bgi* files that store information on the genetic variants and the position of their corresponding data in the bgen files, and by a sample file that stores information on the individual IDs. pgen files (also called PLINK2 files), which can store imputed data as well, and seems a bit more compressed than bgen files. PLINK2 provides many functions to work with this format. Many other formats that you can usually convert from using PLINK. 1.2 The bigSNP format from {bigsnpr} Package {bigsnpr} uses a class called bigSNP for representing SNP data. A bigSNP object is merely a list with the three following elements: $genotypes: A FBM.code256. Rows are samples and columns are genetic variants. This stores genotype calls or dosages (rounded to 2 decimal places). More about this format below. $fam: A data.frame with some information on the samples. $map: A data.frame with some information on the genetic variants. The code used in class FBM.code256 for imputed data is e.g.  bigsnpr::CODE_DOSAGE #&gt; [1] 0.00 1.00 2.00 NA 0.00 1.00 2.00 0.00 0.01 0.02 0.03 0.04 0.05 0.06 #&gt; [15] 0.07 0.08 0.09 0.10 0.11 0.12 0.13 0.14 0.15 0.16 0.17 0.18 0.19 0.20 #&gt; [29] 0.21 0.22 0.23 0.24 0.25 0.26 0.27 0.28 0.29 0.30 0.31 0.32 0.33 0.34 #&gt; [43] 0.35 0.36 0.37 0.38 0.39 0.40 0.41 0.42 0.43 0.44 0.45 0.46 0.47 0.48 #&gt; [57] 0.49 0.50 0.51 0.52 0.53 0.54 0.55 0.56 0.57 0.58 0.59 0.60 0.61 0.62 #&gt; [71] 0.63 0.64 0.65 0.66 0.67 0.68 0.69 0.70 0.71 0.72 0.73 0.74 0.75 0.76 #&gt; [85] 0.77 0.78 0.79 0.80 0.81 0.82 0.83 0.84 0.85 0.86 0.87 0.88 0.89 0.90 #&gt; [99] 0.91 0.92 0.93 0.94 0.95 0.96 0.97 0.98 0.99 1.00 1.01 1.02 1.03 1.04 #&gt; [113] 1.05 1.06 1.07 1.08 1.09 1.10 1.11 1.12 1.13 1.14 1.15 1.16 1.17 1.18 #&gt; [127] 1.19 1.20 1.21 1.22 1.23 1.24 1.25 1.26 1.27 1.28 1.29 1.30 1.31 1.32 #&gt; [141] 1.33 1.34 1.35 1.36 1.37 1.38 1.39 1.40 1.41 1.42 1.43 1.44 1.45 1.46 #&gt; [155] 1.47 1.48 1.49 1.50 1.51 1.52 1.53 1.54 1.55 1.56 1.57 1.58 1.59 1.60 #&gt; [169] 1.61 1.62 1.63 1.64 1.65 1.66 1.67 1.68 1.69 1.70 1.71 1.72 1.73 1.74 #&gt; [183] 1.75 1.76 1.77 1.78 1.79 1.80 1.81 1.82 1.83 1.84 1.85 1.86 1.87 1.88 #&gt; [197] 1.89 1.90 1.91 1.92 1.93 1.94 1.95 1.96 1.97 1.98 1.99 2.00 NA NA #&gt; [211] NA NA NA NA NA NA NA NA NA NA NA NA NA NA #&gt; [225] NA NA NA NA NA NA NA NA NA NA NA NA NA NA #&gt; [239] NA NA NA NA NA NA NA NA NA NA NA NA NA NA #&gt; [253] NA NA NA NA where the first four elements are used to store genotype calls, the next three to store imputed allele counts, and the next 201 values to store dosages rounded to 2 decimal places. This allows for handling many types of data while storing each elements using one byte only (x4 compared to bed files, but /8 compared to doubles). Package {bigsnpr} also provides functions for directly working on bed files with a small percentage of missing values (Privé, Luu, Blum, McGrath, &amp; Vilhjálmsson, 2020). 1.3 Getting a bigSNP object To read a bigSNP object from bed/bim/fam files, you can use functions snp_readBed() and snp_readBed2() (the second can read a subset of individuals/variants and use parallelism). To read dosages from BGEN files, you can use function snp_readBGEN(). This function takes around 40 minutes to read 1M variants for 400K individuals using 15 cores. Note that this function currently works only for BGEN v1.2 with probabilities stored as 8 bits (cf. this issue), which is the case for e.g. the UK Biobank files. To read any format used in genetics, you can always convert blocks of the data to text files using PLINK, read these using bigreadr::fread2(), and fill part of the resulting FBM. For example, see the code I used to convert the iPSYCH imputed data from the RICOPILI pipeline to my bigSNP format. library(bigsnpr) #&gt; Loading required package: bigstatsr bedfile &lt;- system.file(&quot;extdata&quot;, &quot;example.bed&quot;, package = &quot;bigsnpr&quot;) (rds &lt;- snp_readBed2(bedfile, backingfile = tempfile())) #&gt; [1] &quot;C:\\\\Users\\\\au639593\\\\AppData\\\\Local\\\\Temp\\\\RtmpEDY2gR\\\\file3a7c21f141a7.rds&quot; bigsnp &lt;- snp_attach(rds) (G &lt;- bigsnp$genotypes) #&gt; A Filebacked Big Matrix of type &#39;code 256&#39; with 517 rows and 4542 columns. G[1:5, 1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 0 0 2 0 1 #&gt; [2,] 1 0 1 0 0 #&gt; [3,] 0 1 1 0 2 #&gt; [4,] 0 0 2 0 2 #&gt; [5,] 1 0 0 0 2 str(bigsnp$fam) #&gt; &#39;data.frame&#39;: 517 obs. of 6 variables: #&gt; $ family.ID : chr &quot;POP1&quot; &quot;POP1&quot; &quot;POP1&quot; &quot;POP1&quot; ... #&gt; $ sample.ID : chr &quot;IND0&quot; &quot;IND1&quot; &quot;IND2&quot; &quot;IND3&quot; ... #&gt; $ paternal.ID: int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ maternal.ID: int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ sex : int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ affection : int 1 1 2 1 1 1 1 1 1 1 ... str(bigsnp$map) #&gt; &#39;data.frame&#39;: 4542 obs. of 6 variables: #&gt; $ chromosome : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ marker.ID : chr &quot;SNP0&quot; &quot;SNP1&quot; &quot;SNP2&quot; &quot;SNP3&quot; ... #&gt; $ genetic.dist: int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ physical.pos: int 112 1098 2089 3107 4091 5091 6107 7103 8090 9074 ... #&gt; $ allele1 : chr &quot;A&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; ... #&gt; $ allele2 : chr &quot;T&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ... obj.bed &lt;- bed(bedfile) obj.bed[1:5, 1:5] #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 0 0 2 0 1 #&gt; [2,] 1 0 1 0 0 #&gt; [3,] 0 1 1 0 2 #&gt; [4,] 0 0 2 0 2 #&gt; [5,] 1 0 0 0 2 str(obj.bed$fam) #&gt; &#39;data.frame&#39;: 517 obs. of 6 variables: #&gt; $ family.ID : chr &quot;POP1&quot; &quot;POP1&quot; &quot;POP1&quot; &quot;POP1&quot; ... #&gt; $ sample.ID : chr &quot;IND0&quot; &quot;IND1&quot; &quot;IND2&quot; &quot;IND3&quot; ... #&gt; $ paternal.ID: int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ maternal.ID: int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ sex : int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ affection : int 1 1 2 1 1 1 1 1 1 1 ... str(obj.bed$map) #&gt; &#39;data.frame&#39;: 4542 obs. of 6 variables: #&gt; $ chromosome : int 1 1 1 1 1 1 1 1 1 1 ... #&gt; $ marker.ID : chr &quot;SNP0&quot; &quot;SNP1&quot; &quot;SNP2&quot; &quot;SNP3&quot; ... #&gt; $ genetic.dist: int 0 0 0 0 0 0 0 0 0 0 ... #&gt; $ physical.pos: int 112 1098 2089 3107 4091 5091 6107 7103 8090 9074 ... #&gt; $ allele1 : chr &quot;A&quot; &quot;T&quot; &quot;T&quot; &quot;T&quot; ... #&gt; $ allele2 : chr &quot;T&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ... bgen &lt;- runonce::download_file( &quot;https://enkre.net/cgi-bin/code/bgen/raw/3ec770a829a753282b5cb45afc3f4eda036b246705b76f9037b6cc98c41a4194?at=example.8bits.bgen&quot;, fname = &quot;example.bgen&quot;) bgi &lt;- runonce::download_file( &quot;https://enkre.net/cgi-bin/code/bgen/raw/dc7276e0f0e2e096f58d2dac645aa5711de2cd64c3b29a07a80575e175344f78?at=example.8bits.bgen.bgi&quot;, fname = &quot;example.bgen.bgi&quot;) sample &lt;- runonce::download_file( &quot;https://enkre.net/cgi-bin/code/bgen/raw/a3c4d8e4c132048a502dc00a3e51362f98eda5a2889df695ba260dc48c327fd9?at=example.sample&quot;, fname = &quot;example.sample&quot;) # What should you be careful about when reading this file? readLines(sample, n = 5) #&gt; [1] &quot;ID_1&quot; &quot;0&quot; &quot;sample_001&quot; &quot;sample_002&quot; &quot;sample_003&quot; library(bigsnpr) (var_info &lt;- snp_readBGI(bgi)) #&gt; # A tibble: 199 × 8 #&gt; chromosome position rsid number_of_alleles allele1 allele2 #&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 01 1001 RSID_101 2 A G #&gt; 2 01 2000 RSID_2 2 A G #&gt; 3 01 2001 RSID_102 2 A G #&gt; 4 01 3000 RSID_3 2 A G #&gt; 5 01 3001 RSID_103 2 A G #&gt; 6 01 4000 RSID_4 2 A G #&gt; 7 01 4001 RSID_104 2 A G #&gt; 8 01 5000 RSID_5 2 A G #&gt; 9 01 5001 RSID_105 2 A G #&gt; 10 01 6000 RSID_6 2 A G #&gt; # ℹ 189 more rows #&gt; # ℹ 2 more variables: file_start_position &lt;dbl&gt;, size_in_bytes &lt;int&gt; snp_id &lt;- with(var_info[1:10, ], paste(chromosome, position, allele1, allele2, sep = &quot;_&quot;)) (rds &lt;- snp_readBGEN(bgen, backingfile = tempfile(), list_snp_id = list(snp_id))) #&gt; [1] &quot;C:\\\\Users\\\\au639593\\\\AppData\\\\Local\\\\Temp\\\\RtmpEDY2gR\\\\file3a7c715765a.rds&quot; bigsnp &lt;- snp_attach(rds) (G &lt;- bigsnp$genotypes) #&gt; A Filebacked Big Matrix of type &#39;code 256&#39; with 500 rows and 10 columns. str(bigsnp$map) #&gt; tibble [10 × 8] (S3: tbl_df/tbl/data.frame) #&gt; $ chromosome : chr [1:10] &quot;01&quot; &quot;01&quot; &quot;01&quot; &quot;01&quot; ... #&gt; $ marker.ID : chr [1:10] &quot;SNPID_101&quot; &quot;SNPID_2&quot; &quot;SNPID_102&quot; &quot;SNPID_3&quot; ... #&gt; $ rsid : chr [1:10] &quot;RSID_101&quot; &quot;RSID_2&quot; &quot;RSID_102&quot; &quot;RSID_3&quot; ... #&gt; $ physical.pos: int [1:10] 1001 2000 2001 3000 3001 4000 4001 5000 5001 6000 #&gt; $ allele1 : chr [1:10] &quot;A&quot; &quot;A&quot; &quot;A&quot; &quot;A&quot; ... #&gt; $ allele2 : chr [1:10] &quot;G&quot; &quot;G&quot; &quot;G&quot; &quot;G&quot; ... #&gt; $ freq : num [1:10] 0.583 0.802 0.198 0.483 0.517 ... #&gt; $ info : num [1:10] 0.975 0.668 0.666 0.952 0.952 ... 1.4 The FBM format from {bigstatsr} The format provided in package {bigstatsr} is called a Filebacked Big Matrix (FBM). It is an on-disk matrix format which is accessed through memory-mapping. How memory-mapping works: when you access the 1st element (1st row, 1st col), it accesses a block (say the first column) from disk into memory (RAM) when you access the 2nd element (2nd row, 1st col), it is already in memory so it is accessed very fast when you access the second column, you access from disk again (once) you can access many columns like that, until you do not have enough memory anymore some space is freed automatically so that new columns can be accessed into memory everything is seamlessly managed by the operating system (OS) it is also very convenient for parallelism as data is shared between processes All the elements of an FBM have the same type; supported types are: \"double\" (the default, double precision – 8 bytes per element) \"float\" (single precision – 4 bytes) \"integer\" (signed, so between \\(\\text{-}2^{31}\\) and (\\(2^{31} \\text{ - } 1\\)) – 4 bytes) \"unsigned short\": can store integer values from \\(0\\) to \\(65535\\) (2 bytes) \"raw\" or \"unsigned char\": can store integer values from \\(0\\) to \\(255\\) (1 byte). It is the basis for class FBM.code256 in order to access 256 arbitrary different numeric values. It is used in package {bigsnpr} (see above). 1.5 Working with an FBM 1.5.1 Similar accessor as R matrices library(bigstatsr) X &lt;- FBM(2, 5, init = 1:10, backingfile = &quot;test&quot;)$save() X$backingfile ## the file where the data is actually stored #&gt; [1] &quot;C:\\\\Users\\\\au639593\\\\OneDrive - Aarhus universitet\\\\Desktop\\\\statgen-course\\\\test.bk&quot; X &lt;- big_attach(&quot;test.rds&quot;) ## can get the FBM from any R session You can access the whole FBM as an R matrix in memory using X[]. However, if the matrix is too large to fit in memory, you should always access only a subset of columns. Note that the elements of the FBM are stored column-wise (as for a standard R matrix). Therefore, be careful not to access a subset of rows, since it would read non-contiguous elements from the whole matrix from disk. X[, 1] ## ok (must read first column only) #&gt; [1] 1 2 X[1, ] ## bad (must read all data from disk) #&gt; [1] 1 3 5 7 9 X[] ## super bad (standard R matrix in memory) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 3 5 7 9 #&gt; [2,] 2 4 6 8 10 1.5.2 Split-(par)Apply-Combine Strategy colSums(X[]) ## super bad #&gt; [1] 3 7 11 15 19 Instead, the split-apply-combine strategy works well for applying standard R functions to FBMs (possibly in parallel), as implemented in big_apply(). Learn more with this tutorial on big_apply(). Compute the sum of each column of X &lt;- big_attachExtdata() using big_apply(). 1.5.3 Similar accessor as Rcpp matrices // [[Rcpp::plugins(cpp11)]] // [[Rcpp::depends(bigstatsr, rmio)]] #include &lt;bigstatsr/BMAcc.h&gt; // [[Rcpp::export]] NumericVector bigcolsums(Environment BM) { XPtr&lt;FBM&gt; xpBM = BM[&quot;address&quot;]; // get the external pointer BMAcc&lt;double&gt; macc(xpBM); // create an accessor to the data size_t n = macc.nrow(); // similar code as for an Rcpp::NumericMatrix size_t m = macc.ncol(); // similar code as for an Rcpp::NumericMatrix NumericVector res(m); for (size_t j = 0; j &lt; m; j++) for (size_t i = 0; i &lt; n; i++) res[j] += macc(i, j); // similar code as for an Rcpp::NumericMatrix return res; } For a subset of the data: // [[Rcpp::plugins(cpp11)]] // [[Rcpp::depends(bigstatsr, rmio)]] #include &lt;bigstatsr/BMAcc.h&gt; // [[Rcpp::export]] NumericVector bigcolsums2(Environment BM, const IntegerVector&amp; rowInd, const IntegerVector&amp; colInd) { XPtr&lt;FBM&gt; xpBM = BM[&quot;address&quot;]; // accessor to a sub-view of the data -&gt; the only line of code that should change SubBMAcc&lt;double&gt; macc(xpBM, rowInd, colInd, 1); size_t n = macc.nrow(); size_t m = macc.ncol(); NumericVector res(m); for (size_t j = 0; j &lt; m; j++) for (size_t i = 0; i &lt; n; i++) res[j] += macc(i, j); return res; } 1.5.4 Some summary functions are already implemented big_colstats(X) # sum and var (for each column) #&gt; sum var #&gt; 1 3 0.5 #&gt; 2 7 0.5 #&gt; 3 11 0.5 #&gt; 4 15 0.5 #&gt; 5 19 0.5 big_scale()(X) # mean and sd (for each column) #&gt; center scale #&gt; 1 1.5 0.7071068 #&gt; 2 3.5 0.7071068 #&gt; 3 5.5 0.7071068 #&gt; 4 7.5 0.7071068 #&gt; 5 9.5 0.7071068 To only use a subset of the data stored as an FBM, you should almost never make a copy of the data; instead, use parameters ind.row (or ind.train) and ind.col to apply functions to a subset of the data. References Privé, F., Luu, K., Blum, M.G., McGrath, J.J., &amp; Vilhjálmsson, B.J. (2020). Efficient toolkit implementing best practices for principal component analysis of population genetic data. Bioinformatics, 36, 4449–4457. "],["references.html", "References", " References Privé, F., Luu, K., Blum, M.G., McGrath, J.J., &amp; Vilhjálmsson, B.J. (2020). Efficient toolkit implementing best practices for principal component analysis of population genetic data. Bioinformatics, 36, 4449–4457. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
